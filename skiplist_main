import hashlib, random, struct, time

def canonical_bytes(arg):
    """serialize arg in a canonical way so hashes are consistent"""
    if isinstance(arg, int):
        if arg == 0:
            b = b'\x00'
        else:
            b = arg.to_bytes((arg.bit_length() + 7) // 8, 'big')
        return b'I' + struct.pack('>I', len(b)) + b
    elif isinstance(arg, str):
        b = arg.encode('utf-8')
        return b'S' + struct.pack('>I', len(b)) + b
    elif isinstance(arg, bytes):
        return b'B' + struct.pack('>I', len(arg)) + arg
    elif arg is None:
        return b'N' + struct.pack('>I', 0)
    else:
        b = str(arg).encode('utf-8')
        return b'S' + struct.pack('>I', len(b)) + b

def sha256(x: bytes) -> bytes:
    return hashlib.sha256(x).digest()


class Node:
    def __init__(self, level, key=None):
        self.level = level
        self.key = key
        self.down = None
        self.right = None
        self.rank = 0
        self.label = None
        self.leaf_hash = None


class AuthSkipList:
    def __init__(self, max_level=8):
        self.max_level = max_level
        self.level_heads = [Node(l) for l in range(max_level + 1)]
        for l in range(max_level, 0, -1):
            self.level_heads[l].down = self.level_heads[l-1]
        self.head = self.level_heads[max_level]
        self.count = 0

    def _hash_leaf(self, key):
        return sha256(canonical_bytes(str(key)))

    def random_level(self):
        lvl = 0
        while random.random() < 0.5 and lvl < self.max_level:
            lvl += 1
        return lvl

    def insert(self, key):
        lvl = self.random_level()
        prevs = [None]*(self.max_level+1)
        node = self.head
        for l in reversed(range(self.max_level+1)):
            while node.right and node.right.key is not None and node.right.key < key:
                node = node.right
            prevs[l] = node
            if node.down:
                node = node.down

        down_link = None
        for l in range(lvl+1):
            new = Node(l, key)
            if l == 0:
                new.leaf_hash = self._hash_leaf(key)
            new.down = down_link
            new.right = prevs[l].right
            prevs[l].right = new
            down_link = new
        self.count += 1
        self.recompute()

    def recompute(self):
        # reset
        for l in range(self.max_level+1):
            n = self.level_heads[l]
            while n:
                n.rank = 0
                n.label = None
                n = n.right

        # leaf ranks
        total = 0
        n = self.level_heads[0].right
        while n:
            n.rank = 1
            total += 1
            n = n.right
        self.level_heads[0].rank = total

        # internal ranks
        for l in range(1, self.max_level+1):
            n = self.level_heads[l].right
            while n:
                d = n.down
                bound = n.right.down if n.right else None
                subtotal = 0
                while d is not None and d is not bound:
                    subtotal += d.rank
                    d = d.right
                n.rank = subtotal
                n = n.right

        # top totals
        for l in range(self.max_level+1):
            subtotal = 0
            n = self.level_heads[l].right
            while n:
                subtotal += n.rank
                n = n.right
            self.level_heads[l].rank = subtotal

        # compute labels
        for l in range(self.max_level+1):
            nodes = []
            n = self.level_heads[l]
            while n:
                nodes.append(n)
                n = n.right
            for v in reversed(nodes):
                right_hash = v.right.label if (v.right and v.right.label) else b''
                if v.level == 0:
                    leaf_data = v.leaf_hash if v.leaf_hash else b''
                    ser = (canonical_bytes(v.level) +
                           canonical_bytes(v.rank) +
                           canonical_bytes(leaf_data) +
                           canonical_bytes(right_hash))
                else:
                    down_hash = v.down.label if (v.down and v.down.label) else b''
                    ser = (canonical_bytes(v.level) +
                           canonical_bytes(v.rank) +
                           canonical_bytes(down_hash) +
                           canonical_bytes(right_hash))
                v.label = sha256(ser)

    def get_proof_chain(self, rank):
        # locate leaf
        leaf = self.level_heads[0].right
        for _ in range(rank-1):
            leaf = leaf.right

        chain = [leaf]

        def is_parent(v, child):
            if v.down is None:
                return False
            d = v.down
            bound = v.right.down if v.right else None
            while d is not None and d is not bound:
                if d is child:
                    return True
                d = d.right
            return False

        for l in range(1, self.max_level+1):
            p = None
            n = self.level_heads[l].right
            while n:
                if is_parent(n, chain[-1]):
                    p = n
                    break
                n = n.right
            if p:
                chain.append(p)

        if chain[-1] is not self.head:
            chain.append(self.head)

        proof = []
        for v in chain:
            entry = dict(level=v.level, rank=v.rank,
                         right=v.right.label.hex() if v.right and v.right.label else "",
                         label=v.label.hex() if v.label else "")
            if v.level == 0:
                entry['leaf'] = v.leaf_hash.hex() if v.leaf_hash else ""
            else:
                entry['down'] = v.down.label.hex() if v.down and v.down.label else ""
            proof.append(entry)
        return (leaf.leaf_hash.hex() if leaf.leaf_hash else "").lower(), proof

    def get_root(self):
        return self.head.label


def verify_chain(root_hash, leaf_val, proof):
    if not proof: return False, 0
    gammas = []
    total_bytes = 0
    first = proof[0]
    if first['level'] != 0: return False, 0, gammas
    if not first.get('leaf'): return False, 0, gammas
    if leaf_val and first['leaf'].lower() != leaf_val.lower():
        return False, 0, gammas


    for entry in proof:
        lvl = entry['level']
        rank = entry['rank']
        right_bytes = bytes.fromhex(entry['right']) if entry.get('right') else b''
        if lvl == 0:
            leaf_bytes = bytes.fromhex(entry['leaf']) if entry.get('leaf') else b''
            ser = (canonical_bytes(lvl) +
                   canonical_bytes(rank) +
                   canonical_bytes(leaf_bytes) +
                   canonical_bytes(right_bytes))
        else:
            down_bytes = bytes.fromhex(entry['down']) if entry.get('down') else b''
            ser = (canonical_bytes(lvl) +
                   canonical_bytes(rank) +
                   canonical_bytes(down_bytes) +
                   canonical_bytes(right_bytes))

        computed = sha256(ser)
        gammas.append(computed.hex())
        total_bytes += len(ser)

        if computed != bytes.fromhex(entry['label']):
            print("Gamma mismatch ", lvl)
            return False, total_bytes, gammas

    ok = (bytes.fromhex(proof[-1]['label']) == root_hash)
    return ok, total_bytes, gammas


# Demo
if __name__ == "__main__":
    random.seed(1)
    asl = AuthSkipList(max_level=5)
    vals = sorted(random.sample(range(1000, 9999), 32))
    for v in vals:
        asl.insert(v)

    root = asl.get_root()
    print("Root hash:", root.hex())

    total_bytes = 0
    total_gamma_storage = 0
    total_proof_time = 0.0
    total_verify_time = 0.0
    total = 0
    n = len(vals)

    for i in range(1, len(vals)+1):
      #comp time
      t0 = time.perf_counter()
      leaf_val, proof = asl.get_proof_chain(i)
      t1 = time.perf_counter()
      total_proof_time += (t1-t0)

      #verification time
      t2 = time.perf_counter()
      ok, nbytes, gammas = verify_chain(root, leaf_val, proof)
      t3 = time.perf_counter()
      total_verify_time += (t3 - t2)

      total_bytes += nbytes

      gamma_storage = sum(len(bytes.fromhex(g)) for g in gammas)
      total_gamma_storage += gamma_storage

      print("Gamma values: ", [g[:10] + "..." for g in gammas])
      print(f"{i:2d}: ok = {ok}, proof_bytes={nbytes}, gamma_storage={gamma_storage}")


    print("\n=== Summary ===")
    print("Avg proof bytes:", total_bytes/len(vals))
    print("Avg gamma storage: ", total_gamma_storage / n)
    print("Avg proof computation time: %.6f sec" % (total_proof_time / n))
    print("Avg proof verification time: %.6f sec" % (total_verify_time / n))

import hashlib, math, random, struct, time, pandas as pd

def canonical_bytes(arg):
    """serialize arg in a canonical way so hashes are consistent"""
    if isinstance(arg, int):
        if arg == 0:
            b = b'\x00'
        else:
            b = arg.to_bytes((arg.bit_length() + 7) // 8, 'big')
        return b'I' + struct.pack('>I', len(b)) + b
    elif isinstance(arg, str):
        b = arg.encode('utf-8')
        return b'S' + struct.pack('>I', len(b)) + b
    elif isinstance(arg, bytes):
        return b'B' + struct.pack('>I', len(arg)) + arg
    elif arg is None:
        return b'N' + struct.pack('>I', 0)
    else:
        b = str(arg).encode('utf-8')
        return b'S' + struct.pack('>I', len(b)) + b

def sha256(x: bytes) -> bytes:
    return hashlib.sha256(x).digest()


class Node:
    def __init__(self, level, key=None):
        self.level = level
        self.key = key
        self.down = None
        self.right = None
        self.rank = 0
        self.label = None
        self.leaf_hash = None
        self.parent = None


class AuthSkipList:
    def __init__(self, max_level=8):
        self.max_level = max_level
        self.level_heads = [Node(l) for l in range(max_level + 1)]
        for l in range(max_level, 0, -1):
            self.level_heads[l].down = self.level_heads[l-1]
        self.head = self.level_heads[max_level]
        self.count = 0

    def _hash_leaf(self, key):
        return sha256(canonical_bytes(str(key)))

    def random_level(self):
        lvl = 0
        while random.random() < 0.5 and lvl < self.max_level:
            lvl += 1
        return lvl

    def insert(self, key):
        lvl = self.random_level()
        prevs = [None]*(self.max_level+1)
        node = self.head
        for l in reversed(range(self.max_level+1)):
            while node.right and node.right.key is not None and node.right.key < key:
                node = node.right
            prevs[l] = node
            if node.down:
                node = node.down

        down_link = None
        for l in range(lvl+1):
            new = Node(l, key)
            if l == 0:
                new.leaf_hash = self._hash_leaf(key)
            new.down = down_link

            if down_link is not None:
              down_link.parent = new

            new.right = prevs[l].right
            prevs[l].right = new
            down_link = new
        self.count += 1
        self.recompute()

    def recompute(self):
        # reset
        for l in range(self.max_level+1):
            n = self.level_heads[l]
            while n:
                n.rank = 0
                n.label = None
                n = n.right

        # leaf ranks
        total = 0
        n = self.level_heads[0].right
        while n:
            n.rank = 1
            total += 1
            n = n.right
        self.level_heads[0].rank = total

        # internal ranks
        for l in range(1, self.max_level+1):
            n = self.level_heads[l].right
            while n:
                d = n.down
                bound = n.right.down if n.right else None
                subtotal = 0
                while d is not None and d is not bound:
                    subtotal += d.rank
                    d = d.right
                n.rank = subtotal
                n = n.right

        # top totals
        for l in range(self.max_level+1):
            subtotal = 0
            n = self.level_heads[l].right
            while n:
                subtotal += n.rank
                n = n.right
            self.level_heads[l].rank = subtotal;

        # compute labels
        for l in range(self.max_level+1):
            nodes = []
            n = self.level_heads[l]
            while n:
                nodes.append(n)
                n = n.right
            for v in reversed(nodes):
                right_hash = v.right.label if (v.right and v.right.label) else b''
                if v.level == 0:
                    leaf_data = v.leaf_hash if v.leaf_hash else b''
                    ser = (canonical_bytes(v.level) +
                           canonical_bytes(v.rank) +
                           canonical_bytes(leaf_data) +
                           canonical_bytes(right_hash))
                else:
                    down_hash = v.down.label if (v.down and v.down.label) else b''
                    ser = (canonical_bytes(v.level) +
                           canonical_bytes(v.rank) +
                           canonical_bytes(down_hash) +
                           canonical_bytes(right_hash))
                v.label = sha256(ser)

    def get_proof_chain(self, rank):

      if rank < 1 or rank > self.count:
        raise IndexError("rank out of range")


      leaf = self.level_heads[0].right
      for _ in range(rank - 1):
        if leaf is None:
            raise IndexError("rank out of range")
        leaf = leaf.right

      chain = []
      node = leaf
      while node:
        chain.append(node)
        node = node.parent

      if chain[-1] is not self.head:
        chain.append(self.head)

 
      proof = []
      for v in chain:
        entry = {
            'level': v.level,
            'rank': v.rank,
            'right': v.right.label.hex() if (v.right and v.right.label) else "",
            'label': v.label.hex() if v.label else ""
        }
        if v.level == 0:
            entry['leaf'] = v.leaf_hash.hex() if v.leaf_hash else ""
        else:
            entry['down'] = v.down.label.hex() if (v.down and v.down.label) else ""
        proof.append(entry)

      return (leaf.leaf_hash.hex() if leaf.leaf_hash else "").lower(), proof


    def get_root(self):
        return self.head.label


def verify_chain(root_hash, leaf_val, proof):
    if not proof: return False, 0
    gammas = []
    total_bytes = 0
    first = proof[0]
    if first['level'] != 0: return False, 0, gammas
    if not first.get('leaf'): return False, 0, gammas
    if leaf_val and first['leaf'].lower() != leaf_val.lower():
        return False, 0, gammas


    for entry in proof:
        lvl = entry['level']
        rank = entry['rank']
        right_bytes = bytes.fromhex(entry['right']) if entry.get('right') else b''
        if lvl == 0:
            leaf_bytes = bytes.fromhex(entry['leaf']) if entry.get('leaf') else b''
            ser = (canonical_bytes(lvl) +
                   canonical_bytes(rank) +
                   canonical_bytes(leaf_bytes) +
                   canonical_bytes(right_bytes))
        else:
            down_bytes = bytes.fromhex(entry['down']) if entry.get('down') else b''
            ser = (canonical_bytes(lvl) +
                   canonical_bytes(rank) +
                   canonical_bytes(down_bytes) +
                   canonical_bytes(right_bytes))

        computed = sha256(ser)
        gammas.append(computed.hex())
        total_bytes += len(ser)

        if computed != bytes.fromhex(entry['label']):
            print("Gamma mismatch ", lvl)
            return False, total_bytes, gammas

    ok = (bytes.fromhex(proof[-1]['label']) == root_hash)
    return ok, total_bytes, gammas


# Demo
if __name__ == "__main__":
    random.seed(1)

    sample_sizes = [2**i for i in range(10, 61, 10)]  # 2^10, 2^20, 2^30, 2^40, 2^50, 2^60
    results = []

    for n in sample_sizes:
        print(f"\n=== Simulating n = 2^{int(math.log2(n))} ({n:.2e}) elements ===")

        # We’ll only actually insert a small subset of elements to keep it manageable
        sample_count = min(1000, n)  # limit to 1000 actual nodes
        asl = AuthSkipList(max_level=min(20, int(math.log2(sample_count))))

        vals = sorted(random.sample(range(1, 10_000_000_000), sample_count))
        for v in vals:
            asl.insert(v)
        root = asl.get_root()

        # sample a few proof verifications
        test_indices = random.sample(range(1, sample_count + 1), min(20, sample_count))

        proof_times = []
        verify_times = []
        gamma_sizes = []

        for i in test_indices:
            t0 = time.perf_counter()
            leaf_val, proof = asl.get_proof_chain(i)
            t1 = time.perf_counter()
            proof_time = (t1 - t0) * 1e6  # µs

            t2 = time.perf_counter()
            ok, nbytes, gammas = verify_chain(root, leaf_val, proof)
            t3 = time.perf_counter()
            verify_time = (t3 - t2) * 1e6

            gamma_storage = sum(len(bytes.fromhex(g)) for g in gammas)

            proof_times.append(proof_time)
            verify_times.append(verify_time)
            gamma_sizes.append(gamma_storage)

        results.append({
            "log2(n)": int(math.log2(n)),
            "n (theoretical)": n,
            "actual_sampled": sample_count,
            "avg_proof_time_µs": sum(proof_times) / len(proof_times),
            "avg_verify_time_µs": sum(verify_times) / len(verify_times),
            "avg_gamma_bytes": sum(gamma_sizes) / len(gamma_sizes),
        })

    df = pd.DataFrame(results)
    print("\n=== Results Summary ===")
    print(df)
